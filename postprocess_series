#!/usr/bin/env bash
#------------------------------------------------------------------------------#
# NOTE: Previously sweeped parameter space with ugly hodgpodge of exact doubling;
# dividing into 1, 2.5, 5; and diving into 1, 2, 4; now, we always use the 1, 2, 4
# to logarithmically sweep space. Existing directories have been moved to their
# closest values in this new spacing. White lie, but probably insignificant differences.
#------------------------------------------------------------------------------#
# Processes files in directories matching some glob pattern
dryrun=false
runmode=0 # 0 is control run, the rest are different spindown modes:
filename=4xdaily_inst # prefix for files to be read
pmax=8 # parallelization

# Settings
# climo_start=100 climo_end=2000 # for small-damping runs we wanted! needed fast results, just took
climo_start=200 climo_end=1100 # NOTE: use this for troprad3 runs, which were screwed in last 100 days
spin_start=0 spin_end=100000
globs=('*troprad3*t42l40s*')
flags="--climo " # --eof2d

# Host-specific settings
subfolder=netcdf
storage=$HOME/data
scratch=$HOME
case ${HOSTNAME%%.*} in
  uriah) # special case -- we may store real data here
    storage=/Users/ldavis/data
    scratch=/Users/ldavis/data
    subfolder=
    flags+="--climo-from-daily " # no subfolder
  ;; gauss)
    scratch=/birner-scratch/ldavis # need to use special scratch directory
  ;; euclid)
    storage=/birner-home/ldavis # this directory is backed up; synced with GAUSS home folder
  ;; monde)
    scratch=/mdata1/ldavis
  ;; *) echo "Error: Unknown host, must edit batch script before continuing." && exit 1 ;;
esac
flags="$flags -m=$runmode -s1=$spin_start -s2=$spin_end -c1=$climo_start -c2=$climo_end"

# Iterate
for glob in ${globs[@]}; do
  for input in $scratch/$glob; do
    # Check
    if ! [ -d $input ]; then
      echo "Warning: No directories for glob pattern ${input}." && sleep 3 && continue
    fi
    # echo "Directory: ${input}."

    # Crude parallelization across multiple experiments
    if [ ${#pids[@]} -gt 0 ] && [ $(((counter - 1) % pmax)) -eq 0 ]; then
      echo "Waiting for processes: ${pids[@]}."
      for pid in ${pids[@]}; do
        wait $pid
        [ $? -ne 0 ] && echo "Error: A post-processing step failed." && exit 1
      done; pids=() # reset tracked process ids
    fi

    # Run stuff; will generate individual logs for each 'type' of
    # post-process, and a bigger log that indicates what processes are running
    echo "Experiment: \"${input##*/}\"."
    output="$storage/${input##*/}" # saving processed data
    input="$input/$subfolder"       # loading raw data
    [ ! -d $output ] && mkdir $output
    $dryrun && cmd="echo ./postprocess_run" || cmd="./postprocess_run"

    # Opionally run in parallel, or just linearly
    echo "Log file: tail -f $output/log"
    echo "Calling postprocess with flags: $flags"
    sleep 1
    if [ $pmax -eq 1 ]; then
      $cmd "$filename" "$input" "$output" $flags --debug
    else
      # $cmd "$filename" "$input" "$output" $flags &>logs/pp_${log}.log &
      # $cmd "$filename" "$input" "$output" $flags &>logs/pp_${output##*/}.log &
      $cmd "$filename" "$input" "$output" $flags &>$output/log &
    fi
    pids+=($!) # record process
    echo
  done
done
