#!/bin/bash
################################################################################
# This script runs the GFDL dry core model in blocks of N days, and concurrently
# processes data with "process" script while next block is run
# Concurrent processing can hugely reduce the amount of time needed to get derived
# quantities like heat flux and stuff.
# README.md file has instructions on namelist/diagnostic table parameters
# * 8  cores: 100-day Control  run, T42 64lats was 1181 seconds
# * 12 cores: 100-day Spindown run, T39 60lats was 1022 seconds
# * 8  cores: 10-day  Control  run, T42 64lats was 140  seconds
# * 12 cores: 10-day  Spindown run, T39 60lats was 111  seconds
################################################################################
# First a couple functions for parsing namelist options
################################################################################
function Parse() { # will just print out result; also, trims string quotes, comments, whitespace
  cat input.nml | sed 's/!.*//g' | grep "$1" | cut -d= -f2 | tr -d "\t ,'\""
}
function Replace() { # first argument is param name, second argument is value
  while [ $# -gt 0 ]; do
    ! grep '^[ \t]*\b'${1}'\b' input.nml &>/dev/null && \
      echo "Error: Param \"${1}\" not found in namelist." && exit 1
    space='\([ \t]*\)' # space atom; more readable to set it as a variable
    echo "Replacing param \"${1}\" with \"${2}\"."
    sed -i 's/^'"${space}${1}${space}"'='"${space}"'.*$/\1'${1}'\2=\3'${2}',/g' input.nml
    shift 2
    [ $? -ne 0 ] && echo "Error: Must pass even number of params to Replace function."
  done
}
################################################################################
# Next 
################################################################################
ulimit -s unlimited # set max open files
cwd=$(pwd)
# Declare defaults
cores=8            # number of cores for parallel
mode=0             # default is to run the control
newexper=false     # do not write to existing experiment directory?
resume=false       # do not overwrite existing run block?
days=$(Parse days) # number of days in each block
# Parse input flags
# Read the comments to see explanations for each option
# This function returns an a string that can be used in an eval statement... hideous
function parse_list() { # will echo an eval string
  local nums
  counter=0 # counter
  for num in ${@:2}; do # skip first argument
    [[ "$num" =~ - ]] && break || nums+="$num " # break always returns success
    counter=$(($counter+1)) # shift by 1; this is a number
  done
  echo "($nums); shift $counter" # shift can be 0
}
while [ $# -gt 0 ]; do # echo "Flag: $1"
  case "$1" in
    --resume)         resume=true;  ;; # do not overwrite existing dXXXX-dYYYY folders?
    --new-experiment) newexper=true; ;; # do not write to existing experiment folders?
    --cores)          cores=$2;     shift; ;;
    --start)          tstart=$2;    shift; ;; # starting day
    --end)            tend=$2;      shift; ;; # ending day
    --mode)           mode=$2;      shift; ;; # 0 is control, 1 is spindown, 2...
    --extra)          extra=$2;     shift; ;; # flags for processing script
    --restart)        roverride=$2; shift; ;; # manual override restart directory
    --days-init)      eval "tinit=$(parse_list $@)"; ;; # initial times from control run for spindown run
    --days-blank)     eval "tblank=$(parse_list $@)"; ;;
    --days-keep)      eval "tkeepxyz=$(parse_list $@)"; ;;
    -*) echo "Error: Unknown flag \"$1\"." && exit 1 ;;
    *) [ ! -z $expdir ] && echo "Error: More than one experiment directory specified." && exit 1
      expdir="$1" ;;
  esac; shift # shift by at least one
done
# echo Init: ${tinit[@]}
# echo Blank: ${tblank[@]}
# echo Keep: ${tkeepxyz[@]}
[ -z $expdir ] && echo "Error: You must declare the experiment directory." && exit 1
[[ -z $tstart || -z $tend ]] && echo "Error: Start and end times must be declared." && exit 1

# Check that required scripts are available
fms=$cwd/fms.x       # location of executables
process=$cwd/process # the script for on-the-fly processing
[ ! -x $fms ]     && echo "Error: The executable $fms is missing."                 && exit 1
[ ! -x $process ] && echo "Error: The bash script for processing data is missing." && exit 1

# Optionally exit from script if directory already exists
$newexper && [ -d $expdir ] && echo "Error: Working directory already exists. Continuing..." && exit 1
if [ ! -d $expdir ]; then
  mkdir $expdir # make directory
  [ $? -ne 0 ] && echo "Error: Could not create experiment directory \"$expdir\"." && exit 1
fi

################################################################################
# Helper functions for model runs
################################################################################
# Set up input files for model executable to read
# Takes two arguments: 1) the working directory, and 2) the iteration mode
################################################################################
function Setup() {
  #----------------------------------------------------------------------------#
  # Set up working directory, and move there
  # Action depends on settings
  wdir="$1" # where to move files
  [ $# -ne 1 ] && echo "Error: Setup() functions requires exactly 1 argument." && exit 1
  if [ ! -d $wdir ]; then
    # Resume run here
    resume=false
    echo "Setting up working directory ${wdir##*/}..."
  elif $resume; then
    if compgen -G "$wdir/*.nc" &>/dev/null; then
      echo "Working directory ${wdir##*/} contains failed processing step. Deleting..."
    elif [ -z "$(\ls $wdir/RESTART)" ]; then # need to check *contents*; don't care about empty one
      echo "Working directory ${wdir##*/} contains unfinished integration. Deleting..."
    else
      echo "Working directory ${wdir##*/} contains completed integration. Cancelling..."
      return 1 # breaks out of if statement
    fi
    # Otherwise, resume run and delete 'unfinished' contents
    resume=false
    rm -r $wdir
  else
    echo "Working directory ${wdir##*/} already exists. Deleting..."
    rm -r $wdir
  fi
  #----------------------------------------------------------------------------#
  # Make directory and move stuff over
  mkdir $wdir
  [ $? -ne 0 ] && echo "Error: Failed to create working directory \"$wdir\"." && return 1
  cd $wdir
  cp $fms ./fms.x # move executable inside (declared at top of file)
  mkdir RESTART # model spits out stuff here, can be accepted as input to new iteration
  mkdir INPUT   # model reads from this
  touch field_table # just put empty file, if want no tracers
  # Copy existing namelist file over
  # For shutdown experiments, can edit on the fly to turn off
  # radiation, et cetera, but this is starting point
  [ ! -r "$cwd/input.nml" ]  && echo "Error: input.nml file not found."  && exit 1
  [ ! -r "$cwd/diag_table" ] && echo "Error: diag_table file not found." && exit 1
  cp $cwd/input.nml  ./
  cp $cwd/diag_table ./
  topo=$(Parse "topography_option") # use helper function
  if [[ "$topo" == "input" ]]; then
    [[ ! -r $cwd/topography.data.nc ]] && echo "Error: Topography file not available." && exit 1
    cp $cwd/topography.data.nc ./
  fi
  #----------------------------------------------------------------------------#
  # Change namelist properties
  if [ $mode -gt 0 ]; then case $mode in   # determine spindown type
    1) Replace k_trop 0 k_bl 0 ;;          # turn off all thermal damping
    2) Replace k_trop 0 ;;                 # turn off damping except in boundary layer
    3) Replace k_trop 0 k_bl 0 k_fric 0 ;; # turn off all damping
    4) Replace k_fric 0 ;;                 # turn off friction
    *) echo "Error: Unknown experiment identifier \"$mode\"."; exit 1 ;;
  esac; fi
  # Parent script will test return code; ensure zero here
  return 0
}

################################################################################
# Function for running the next model step from a previous step
# applying post-processing to a previous model step in the background, and organizing
# all the NetCDF files
################################################################################
function Run() {
  local rdir=$1 # the restart direcotry
  [ $# -ne 1 ] && echo "Error: Run() function takes exactly 1 argument." && exit 1
  t0=$(date +%s)
  echo "Running model..."
  # Use MPIRUN to run model in parallel, and select other cores for running processing
  # step in parallel (choosing cores explicitly seemed to be faster)
  # taskset -p $(taskset -p $$ | cut -d ':' -f 2) $! # match processor affinities
  # taskset -cp 0-19 $! 1>/dev/null # $! == pid of last job run in background
  # Note mpirun must be on path
  ! which mpirun &>/dev/null && echo "Error: mpirun not found in \$PATH." && exit 1
  mpirun -np $cores ./fms.x &>log.model # need ./fms.x, not fms
  # Check that model ran successfully
  # FMS prints to standard output 'EXIT CODE: 1' but doesn't actually set
  # the exit code/mpirun doesn't pass that exit code, which is fucking dumb.
  # Instead parse the logfile
  grep 'EXIT CODE: [1-9]' log.model &>/dev/null && \
    echo "Error: Bad exit code from model run step..." && exit 1
  # Wait for previous processing step, if set
  # If unset, means we are just now starting the model runs
  if [ ! -z $pp ]; then # post-processing is active
    wait $pp; estatus=$? # wait command will always exit with exit status of supplied process ID
    if [ $estatus != 0 ]; then
      echo "Error: Exit status $estatus from post-processing previous block..."
      case $estatus in
        1) echo "Something failed during model integration. Check log.model." ;;
        2) echo "Something failed during model interpolation. Check log.interp." ;;
        3) echo "Something failed while getting basic terms. Check log.basic." ;;
        4) echo "Something failed while getting Lorenz cycle terms. Check log.lorenz." ;;
        *) echo "Check log.process; other/miscellaneous failure." ;;
      esac
      exit 1
    fi
  fi
  # Echo timing information
  if [ -r $rdir/log.process ]; then
    tmodel=$(cat log.model | grep "Total runtime*" | xargs | cut -d " " -f 5)
    tprocess=$(tail -1 $rdir/log.process | sed 's/[^0-9]*//g' )
    echo "Model time: ${tmodel%.*}s, Process time: ${tprocess%.*}s."
    if [ "$tprocess" -eq "${tmodel%%.*}" ] 2>/dev/null; then
      echo "Model completion time MINUS processing time: $((${tmodel%%.*} - $tprocess))s."
    fi
  fi
  echo "Time for integration: $(($(date +%s) - $t0))s."
  # Remove some files
  # [ -r INPUT/topography.data.nc ] && rm INPUT/topography.data.nc # remove topography
  [ -d INPUT ] && rm -r INPUT # remove everything
  [ -r logfile.0000.out ] && mv logfile.0000.out log.init # contains init info
  rm fms.x # remove executable, because takes up space
  # Process new data, and remove old data
  # Record the PID when done
  echo "Calling processing script with flags: $(echo $pflags $extra | xargs)"
  $process $pflags $extra &>log.process & # processing
  pp=$! # record PID
  # taskset -p $(taskset -p $$ | cut -d ':' -f 2) $! # match processor affinities
  # taskset -cp 20-23 $! 1>/dev/null # send to particular CPUs
}

################################################################################
# Function for restarting model; put correct files in correct place so 
# fms can read them and continue iteration from a previous state.
################################################################################
# Take one argument: directory where restart files exist
function Restart() {
  # Copy over relevant restart files for exp type; if missing, raise error
  local rdir=$1 # the restart direcotry
  [ $# -ne 1 ] && echo "Error: Restart() function takes exactly 1 argument." && exit 1
  if [ ! -d "$rdir" ] || [ ! -d "$rdir/RESTART" ] || [ -z "$(ls $rdir/RESTART/* 2>/dev/null)" ]; then
    echo "Error: Restart directory $rdir/RESTART does not exist, or is empty." && exit 1
  fi
  resfiles="atmos_model.res atmosphere.res.nc spectral_dynamics.res.nc"
  # resfiles="atmos_model.res atmos_tracers.res.nc fv_rst.res.nc fv_srf_wnd.res.nc" # fv type
  # resfiles="atmos_model.res atmos_tracers.res.nc bgrid_prog_var.res.nc" # brid type
  echo "Moving restart files from ${rdir##*/}/RESTART to ${PWD##*/}/INPUT..."
  for file in $resfiles; do
    [ ! -r $rdir/RESTART/$file ] && echo "Error: Missing restart file ${rdir##*/}/RESTART/${file}." && exit 1
    cp $rdir/RESTART/$file INPUT/$file
  done
}

##############################################################################
# CONTROL RUN
# Run the model in blocks of $days days for control, then optionally choose
# starting points from control for spin-down ensemble experiments
##############################################################################
estatus=0
case $mode in
  0) # CHECK THAT TIMING VARIABLES ARE DECLARED
  # PREPARE FOR THE LOOP
  echo "Running control experiment from day $tstart to day $tend."
  coldstart=true # assume cold start by default
  origin=$(date +%s) # start time
  pday=$(($tstart - $days)) # only time when we do minus days
  cday=$tstart
  nday=$(($tstart + $days))
  while [ $nday -le $tend ]; do
    # MESSAGE AND RESET TIMER/FLAGS
    echo "Running from day $cday to day $nday."
    time=$(date +%s)
    # RUN THE MODEL and COMBINE OUTPUT
    # OPTIONALLY USE THE END OF OTHER CONTROL RUNS TO REDUCE SPINUP TIME
    rdir=$expdir/d$(printf "%04d" $pday)-d$(printf "%04d" $cday)
    cdir=$expdir/d$(printf "%04d" $cday)-d$(printf "%04d" $nday)
    if [ ! -z $roverride ]; then coldstart=false
      if [[ ! $roverride =~ d.*-d.* ]]; then
        echo "Override: Using final day from \"$roverride\" for restart files."
        roverride=($roverride/d*-d*); rdir="${roverride[-1]}" # pick last one; should be sorted
      else
        echo "Override: Using restart files from \"$roverride\"."
        rdir="$roverride" # use specific day sequence
      fi; unset roverride # only ever use this on first 'day' of a new experiment; for subsequent days, continue from earlier day block
      [ ! -d $rdir ] && echo "Error: Override restart directory \"$rdir\" does not exist." && exit 1
    fi
    unset pflags
    [[ " ${tblank[@]} " =~ " $(printf "%04d" $cday) " ]] && pflags+=" -q"
    [[ " ${tkeepxyz[@]} " =~ " $(printf "%04d" $cday) " ]] && pflags+=" -k"
    Setup $cdir # sets up working directory, cd into it
    if [ $? -eq 0 ]; then # setup returns 1 if directory is present and 'resume' option is set
      if ! $coldstart || [ $cday -gt 0 ]; then
        Restart $rdir # put files into RESTART directory
      else
        echo "Cold start."
      fi
      Run $rdir # run model
    fi
    # EXIT FOR INITIAL CONDITION EXPERIMENT
    [ $days -eq 0 ] && break
    # STEP THINGS FORWARD, FOR NEXT ITERATION
    pday=$cday
    cday=$(($pday + $days))
    nday=$(($cday + $days))
  done
  echo "Processing last file..."
  wait $pp; pp=
  echo "The control run completed successfully in $(($(date +%s) - $origin)) seconds!"
  echo "Timestamp: $(date)."

##############################################################################
# SPINDOWN RUNS
# User must specify which namelist params are getting abruptly changed.
##############################################################################
  ;; *) # CHECK THAT TIMING VARIABLES ARE DECLARED
  [ -z $tinit ] && echo "Error: Must declare starting times for spindown experiments." && exit 1
  # PREPARE FOR THE LOOP
  echo "Running spindown experiment $mode from days ${tinit[@]} for $tend days."
  origin=$(date +%s)
  # ITERATE THROUGH STARTING DAYS
  for eday in "${tinit[@]}"; do
    cday=0 # current day relative to start of equilibrium
    nday=$(($cday + $days)) # next day, relative to start
    prefix=$expdir/d$(printf "%04d" $eday) # for successive spindown runs
    fstart=$expdir/d$(printf "%04d" $(($eday - $days)))-d$(printf "%04d" $eday) # for restart files from control
    origin=$(date +%s) # record time
    echo "Starting radiation-off spindown run from day $eday for $tend days."
    while [ $nday -le $tend ]; do
      # SKIP THIS TIME (OPTIONALLY)
      if [ $cday -lt $tstart ]; then
        echo "Skipping $cday."
        pday=$cday # previous day
        cday=$(($pday + $days))
        nday=$(($cday + $days))
        continue
      fi
      # GET DIRECTORIES
      cdir=$prefix-spindown$mode-d$(printf "%04d" $cday)-d$(printf "%04d" $nday)
      [ $cday -eq 0 ] && rdir=$fstart || \
        rdir=$prefix-spindown$mode-d$(printf "%04d" $pday)-d$(printf "%04d" $cday)
      # RUN THE MODEL and COMBINE OUTPUT
      unset pflags
      [[ " ${tblank[@]} " =~ " $(printf "%04d" $cday) " ]] && pflags+=" -q"
      [[ " ${tkeepxyz[@]} " =~ " $(printf "%04d" $cday) " ]] && pflags+=" -k"
      Setup $cdir # sets up working directory, cd into it
      if [ $? == 0 ]; then # returns 1 if we were requested not to overwrite old directories
        Restart $rdir # add restart files
        Run $rdir # run model
      fi
      # STEP THINGS FORWARD, FOR NEXT ITERATION
      pday=$cday # previous day
      cday=$(($pday + $days))
      nday=$(($cday + $days))
    done
    echo "Spindown from $eday completed successfully in $(($(date +%s) - $origin)) seconds!"
    echo "Timestamp: $(date)."
  done
  echo "Processing last file..."
  wait $pp; pp=
  echo "The spindown runs completed successfuly in $(($(date +%s) - $origin)) seconds!"
  echo "Timestamp: $(date)."
################################################################################
# Other experiments types can go below
################################################################################
  ;; *) echo "Error: Unknown experiment type \"$mode\"." && exit 1 ;;
esac

