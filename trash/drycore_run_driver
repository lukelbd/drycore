#!/usr/bin/env bash
#------------------------------------------------------------------------------#
# This was the complicated shit I used to do to run processing in background
# as next model day block ran. Now have greatly improved things -- we process
# data in *parallel* before merging the output files with mppnccombine. So
# no need to do this.
#------------------------------------------------------------------------------#
# Old shit
# taskset -p $(taskset -p $$ | cut -d ':' -f 2) $! # match processor affinities
# taskset -cp 0-19 $! 1>/dev/null # $! == pid of last job run in background

# Check that model ran successfully
# FMS prints error messages to standard output but doesn't actually set
# the exit code/mpirun doesn't pass that exit code, which is fucking dumb.
# We parse the logfile instead
egrep 'EXIT CODE: [1-9]|FATAL from PE' log.model &>/dev/null && \
  echo "Error: Bad exit code from model run step." && exit 1
# Wait for previous processing step, if set
If unset, means we are just now starting the model run
if [ -n "$pp" ]; then # post-processing is active
  echo "Wating for process: $pp"
  wait $pp # wait command will always exit with exit status of supplied process ID
  exit_check $?
fi
# Echo timing information from previous run
# Processing was run in parallel, remember
tmodel=$(cat log.model | grep "Total runtime*" | xargs | cut -d " " -f 5)
echo "Model time: ${tmodel%.*}s." # is just max of the two
if [ -r $rdir/log.process ]; then
  tprocess=$(tail -1 $rdir/log.process | sed 's/[^0-9]*//g' )
  echo "Model time: ${tmodel%.*}s, Previous process time: ${tprocess%.*}s."
else
  echo "Model time: ${tmodel%.*}s." # is just max of the two
fi
# taskset -p $(taskset -p $$ | cut -d ':' -f 2) $!
# taskset -cp 20-23 $! 1>/dev/null # send to particular CPUs
