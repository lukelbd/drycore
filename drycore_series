#!/usr/bin/env bash
################################################################################
# NOTE: Previously sweeped parameter space with ugly hodgpodge of exact doubling;
# dividing into 1, 2.5, 5; and diving into 1, 2, 4; now, we always use the 1, 2, 4
# to logarithmically sweep space. Existing directories have been moved to their
# closest values in this new spacing. White lie, but probably insignificant differences.
################################################################################
usage='drycore_batch [OPTION...] "FORCING_SWEEP_RESOLUTION" --1=[prev:]value[,...] [--2=[prev:]value[,...]] '
doc="This script runs a parameter sweep for the given input series and
list(s) of parameters, using the 'drycore_run' script. It generates standardized
folder names and can modify the namelist and diag_table for the parameters
being changed.

Usage

  $usage

Valid forcing specs

  hs   Held and Suarez, 1994
  pk   Polvani and Kushner, 2004
  dbt  Davis, Birner, and Thompson, TD

Valid sweep specs

  In most cases, the number indicates the boundary layer option.

  base[01]            Just run forcing scheme with default settings, once
  katmos[01]          Change tropospheric damping.
  kfric[01]           Change friction.
  tgrad[01]           Change equator-pole Teq difference
  tshift[01]          Shift Teq meridional gradient poleward or equatorward
  katmos[01]-tgrad    Change both tropospheric damping and equator-pole eqtemp difference
  katmos[01]-tshift   Change both tropospheric damping and temp gradient shift
  katmos[01]-kfric    Change both friction and tropospheric damping.
  kstrat[01]          Change stratospheric damping; number is
                      troposphere-stratosphere damping transition option.

Valid resolution specs

  A string with the format 't[XX]l[YY][spe]'

  * XX is truncation number.
  * YY is vertical level count.
  * Suffix is one character controlling level spacing type:
    * [s]imple/even [s]igma
    * [p]olvani and kushner spacing
    * [e]ra-interim configuration, should be 61 levels in file
      named levels_ecwmf_{nlev}.nml in source directory

Valid parameter specs

  Passed with the flags --1=[prev:]value[,...] [--2=[prev:]value[,...]]

  * --1 is the first parameter for the sweep spec, and --2 is the optional
    second parameter, if this is a diagonal sweep.
  * To run from the end of a *previous* run in the same experiment series,
    use --1=prev:value, e.g. --1=20,40,40:100,100:200.
  * The experiment directory names will be 'force_sweep_resolution_p[XXX][p[YYY]]'
    for parameter 1 XXX and parameter 2 YYY Directories are renamed if
    specified parameters correspond to the 'base' HS94 values.

Options

  -h|--help             Print this message.
  -t|--test             Run quick test, just a few days, maybe 3 restarts.
  -i|--init             Just run model to get a forcing.nc file.
  [-c|--cores]=*        Number of cores.
  [-n|--nodes]=*        Number of nodes, if this is a supercomputer.
  [-dt|--timestep]=*    Number of timesteps.
  [-d|--days]=*         Number of days.
  [-ts|--tstart]=*      Initial day.
  [-te|--tend]=*        Final day.
  [-kts|--ktstart]=*    Initial day where we start keeping full-res data.
  [-kte|--ktend]=*      Final day that we keep full-res data.
  [-td|--testdays]=*    Number of days in each test run block.
  [-tb|--testblocks]=*  Number of blocks for test run.
  -*                    Unknown flags passed to drycore_run.
"
# Load modules
module load impi &>/dev/null # to parallelize the combine process, need mpirun!
module load nco &>/dev/null
# module load ncl &>/dev/null # use conda versions instead, already on path
# module load cdo/1.9.4 &>/dev/null

# Error
raise() {
  echo "Usage: $usage" 1>&2
  echo "Error: $@" 1>&2
  exit 1
}
# Default settings
# NOTE: Really can't push CFL number! Shoot for around 0.5. Got almost instant
# model blow up at 1200s with T106, since upper-level winds probably get to
# around 100m/s (about 200mph)
# NOTE: Working times so far:
# 20 days, 40 days: 600s, even 800s too fast
# 100 days: 800s
secs=0 # normally is zero
days=50
nodes=1
cores=8
mail=true
dryrun=false
dt=600 # for T106, gives 100m/s CFL number of 0.5
tstart=0  # first day of integration; set to 0 for new run.
tend=5500 # for new experiments just do 1200 day integrations, first 200 are spinup
walltime=12:00
queue=economy
# Output settings
outfreq=12      # every 6
frequnits=hours # hours
filename=2xdaily_inst # name for output files
ktstart=1 # first day we keep XYZ data (can't keep all, too much data)
ktend=0 # last day we keep XYZ data
# Test settings
testmode=false
testdays=5
testblocks=5 # number of blocks of testdays
# For supercomputer, idea will be to submit all jobs for the series
# simultaneously, by auto-generating a PBS script
super=false
diag_default=diag_table_default
[[ $HOSTNAME =~ cheyenne* ]] && super=true
# Parse input
unset series_name flags_global
while [ $# -gt 0 ]; do # echo "Flag: $1"
  case "$1" in
    -h|--help) echo "$doc" && exit 0 ;;
    -t|--test)            testmode=true ;;
    -d|--dryrun)          dryrun=true   ;;
    -1=|--1=*)            params1=($(echo ${1#*=} | tr ',' ' ')) ;;
    -2=|--2=*)            params2=($(echo ${1#*=} | tr ',' ' ')) ;;
    -c=*|--cores=*)       cores=${1#*=}      ;;
    -n=*|--nodes=*)       nodes=${1#*=}      ;;
    -dt=*|--timestep=*)   dt=${1#*=}         ;;
    -d=*|--days=*)        days=${1#*=}       ;;
    -ts=*|--tstart=*)     tstart=${1#*=}     ;;
    -te=*|--tend=*)       tend=${1#*=}       ;;
    -kts=*|--ktstart=*)   ktstart=${1#*=}    ;;
    -kte=*|--ktend=*)     ktend=${1#*=}      ;;
    -td=*|--testdays=*)   testdays=${1#*=}   ;;
    -tb=*|--testblocks=*) testblocks=${1#*=} ;;
    -*) flags_global+="$1 " ;;
    *) [ -n "$series_name" ] && raise "More than one experiment series specified."
       series_name="$1" ;;
  esac; shift # shift by at least one
done
# Default experiment series
if [ -z "$series_name" ]; then
  echo "Warning: No experiment name specified. Running default experiment hs_base2_t42l20s."
  series_name='hs_base2_t42l20s'
fi
# Parse experiment series name
# Also echo the critical parallelization info
echo "Nodes: $nodes, Cores: $cores"
force="${series_name%%_*}"
sweep="${series_name#*_}"
sweep="${sweep%%_*}"
reso="${series_name#*_}"
reso="${reso#*_}"
reso="${reso%%_*}"

# Run really fast test run
if $testmode; then
  # exp_restart="${force}_base2_t95l60e" # override previous directory
  # rdays=d0450-d0500 # set restart directory days (leave empty to just use the last subfolder in directory)
  outfreq=12
  frequnits=hours
  filename=test
  days=$testdays
  tstart=0
  tend=$((testdays * testblocks))
  ktstart=$tstart
  ktend=$tend
  walltime=01:00 # real quick test
  queue=regular
fi
# Days for keeping
txyzdata=$(seq $ktstart $days $ktend | tr $'\n' ',') # for saving

#------------------------------------------------------------------------------#
# Paths
#------------------------------------------------------------------------------#
# Storage information for runscript and post-processing script
storage=$HOME
scratch=$HOME # on Euclid, home is unmounted/not backed up; so disk I/O is quick
srcdir=$HOME/gfdl-drycore # model code folder
bindir=./bin # compiled model code folder (should be in this folder)
case ${HOSTNAME%%.*} in
  # olbers)
  #   scratch=''
  # ;; gauss)
  #   scratch=/birner-scratch/ldavis # need to use special scratch directory
  euclid)
    storage=/birner-home/ldavis # this directory is backed up; synced with GAUSS home folder
  ;; monde)
    case $reso in
      # t42l20s) scratch=/mdata2/ldavis ;;
      t42l20s) scratch=/mdata1/ldavis ;;
      *) raise "Unknown scratch destination for experiment with resolution ${reso}." ;;
    esac
  ;; cheyenne*)
    storage=/glade/u/home/davislu
    scratch=/glade/scratch/davislu # https://www2.cisl.ucar.edu/resources/storage-and-file-systems/glade-file-spaces
  ;; *) raise "Unknown host, must edit batch script before continuing." ;;
esac
! [ -d "$storage/data" ] && { mkdir "$storage/data"; echo "Created storage directory."; }
# Copy over the appropriate executable file
cp $bindir/fms.x ./ # location of executables
[ $? -ne 0 ] && raise "fms.x not found in \"$bindir\"."
cp $bindir/mppnccombine.x ./ # location of executables
[ $? -ne 0 ] && raise "mppnccombine.x not found in \"$bindir\"."

#------------------------------------------------------------------------------#
# Helper functions
#------------------------------------------------------------------------------#
# Array membership
member() {
  [[ " ${@:2} " =~ " ${1} " ]]
}

# Add to arrays storing namelist parameters. Fugly but works.
# * If the <value> part is empty (e.g., if this particular experiment
#   series does not change that value), will not add to arrays
# * Function accounts for situation when you pass an empty string parameter
#   or negative number, and have weird strings like "v-" and "v''"
nml_add() {
  while [ $# -ne 0 ]; do
    if [ -n "$2" ] && [ "$2" != "-" ] && [ "$2" != "''" ]; then
      nml_params+=("$1")
      nml_values+=("$2")
    fi
    shift 2
  done
}

# Determine model run name, accounting for "intersection" of experiment series
# and specifying named parameter values for forcing experiments
# Sets global model run variables 'exp_restart' and 'exp_name'
exp_name() {
  # Get params for this experiment and the "continuation" experiment, e.g.
  # --1=40:100 means run this experiment with parmeter 100, from experiment
  # with parameter 40.
  # NOTE: Cannot have "diagonal" continuation experiments, they should always
  # be from an adjacent run in a linear the experiment series.
  local p1 p2 p1f p2f param1 param2 rparam1 rparam2 contin
  local isweep fsweep prefix suffix blopt
  param1=$2
  param2=$3
  isweep=${1#*_}
  isweep=${isweep%%_*} # e.g. katmos, tgrad
  [[ $param1 =~ : ]] && rparam1=${param1%:*} param1=${param1#*:}
  [[ $param2 =~ : ]] && rparam2=${param2%:*} param2=${param2#*:}
  [ -n "$rparam1" ] && [ -n "$rparam2" ] && raise "Cannot do 'diagonal' continuation experiments."
  # Detect whether this is a 'base' experiment. Experiment series can
  # 'intersect' each other, and this ensures we aren't duplicating model runs
  for p1 in $rparam1 $param1; do
    for p2 in $rparam2 $param2; do
      # Continuation experiments get a special suffx
      [ -n "$exp_name" ] && exp_restart="$exp_name" contin=c
      # Get experiment sweep name, *ensuring that we avoid duplicating runs
      # by deferring to different names when possible*
      # TODO: Add to these.
      prefix=${sweep%-*}
      suffix=${sweep#*-}
      blopt=${prefix##*[a-z]} # get number
      fsweep=$isweep # by default, will be same
      # Params for this experiment name
      # WARNING: Can get issues if e.g. go from katmos-tmean base state to
      # pure tmean or katmos experiment. Never overwrite the 'p1' and 'p2' input
      # parameters we are looping through.
      p1f=$p1
      p2f=$p2
      case $isweep in
        # 1D parameter sweeps, pretty simple
        # TODO: Change katmos-mean and katmos-anom to katmosmean and katmosanom,
        # then can run diagonal katmosmean experiments!
        base?) p1f= p2f= ;;
        katmos?|katmos?-mean|katmos?-anom) [[ $p1 == 40 ]] && fsweep=base${blopt} p1f= ;; # base is 40 day zonal-mean or anomaly damping
        tgrad?) [[ $p1 == 60 ]] && fsweep=base${blopt} p1f= ;; # base is 60K contrast
        tmean?) [[ $p1 == 300 ]] && fsweep=base${blopt} p1f= ;; # base is 300K mean
        kfric?) [[ $p1 == 1 ]] && fsweep=base${blopt} p1f= ;;
        tshift?) [[ $p1 == 0 ]] && fsweep=base${blopt} p1f= ;; # zero just means no shift
        kstrat?) [[ $p1 == 40 ]] && fsweep=base2 p1f= ;; # always use classic Held-Suarez for these, i.e. non-constant boundary layer damping
        *) [ -z "$p2" ] && raise "Need second param for diagonal experiment."
        # True 'diagonal' experiments
        # WARNING: Order is important here! Have to detect 'base' experiments
        # before the other ones.
        case "$isweep" in # diagaonal experiment
          katmos?-tgrad)
            [[ $p2 == 60 ]] && fsweep=katmos${blopt} p2f=
            [[ $p1 == 40 ]] && fsweep=tgrad${blopt} p1f=$p2 p2f=
            [[ $p1 == 40 && $p2 == 60 ]] && fsweep=base${blopt} p1f= p2f=
            ;;
          katmos?-tmean)
            [[ $p2 == 300 ]] && fsweep=katmos${blopt} p2f=
            [[ $p1 == 40 ]] && fsweep=tmean${blopt} p1f=$p2 p2f=
            [[ $p1 == 40 && $p2 == 300 ]] && fsweep=base${blopt} p1f= p2f=
            ;;
          katmos?-tshift)
            [[ $p2 == 0 ]] && fsweep=katmos${blopt} p2f=
            [[ $p1 == 40 ]] && fsweep=tshift p1f=$p2 p2f=
            [[ $p1 == 40 && $p2 == 0 ]] && fsweep=base${blopt} p1f= p2f=
            ;;
          katmos?-kfric)
            [[ $p2 == 1 ]] && fsweep=katmos${blopt} p2f=
            [[ $p1 == 40 ]] && fsweep=kfric${blopt} p1f=$p2 p2f=
            [[ $p1 == 40 && $p2 == 1 ]] && fsweep=base${blopt} p1f= p2f=
            ;;
          tgrad?-tshift)
            [[ $p2 == 0 ]] && fsweep=tgrad p2f=
            [[ $p1 == 60 ]] && fsweep=tshift p1f=$p2 p2f=
            [[ $p1 == 60 && $p2 == 0 ]] && fsweep=base${blopt} p1f= p2f=
            ;;
          # Forcing experiments
          katmos?-arctic|katmos?-tropical|katmos?-vortex|katmos?-global|katmos?-surface)
            if [ -n "$rparam1" ] && [ -z "$exp_restart" ]; then
              [[ $p1 == 40 ]] && fsweep=base${blopt} p1f= p2f= || fsweep=katmos${blopt} p2f=
            fi
            ;;
          *) raise "Unknown sweep \"${isweep}\"." ;;
        esac
        ;;
      esac
      [ "$p1f" == 'na' ] && unset -v p1f
      [ "$p2f" == 'na' ] && unset -v p2f
      [ -n "$p1f" ] && p1f="_p$(printf "%08.3f" $p1f)"
      [ -n "$p2f" ] && p2f="p$(printf "%08.3f" $p2f)"
      exp_name=${force}_${fsweep}_${reso}${p1f}${p2f}${contin}
    done
  done
}

# Determine namelist changes and diag table changes
# WARNING TODO: Currently don't explicitly declare all param variables; they
# are global values, and if not reset on every iteration of diagonal experiment,
# could get unexpected namelist values! Make sure to unset variables that are
# changed in a param sweep.
exp_setup() {
  # Parse the experiment name, figure out what needs to be written
  # The 'p values' are values specified in experiment name as pXXXpYYYpZZZ
  local kbl ktrop kstrat kmeso kdepth kfric levels blopt damp delh exph tmean params sweep message
  local butler_arctic butler_tropical butler_vortex forcing_global forcing_surface
  local q0_arctic q0_tropical q0_vortex q0_global q0_surface
  unset nml_params nml_values
  sweep=${1#*_}
  sweep=${sweep%%_*}
  if [[ "$1" =~ _p[0-1] ]]; then # i.e. has param values on end
    params=${1##*_}
    params=${params%c}
    params=($(echo $params | tr -t 'p' ' ' | xargs printf "%.3f "))
  fi
  #----------------------------------------------------------------------------#
  # Add to this as you design new experiment series
  #----------------------------------------------------------------------------#
  prefix=${sweep%-*}
  suffix=${sweep#*-}
  blopt=${prefix##*[a-z]} # get number
  case $sweep in
    # Base
    base1)
      kbl=-40
      ;;
    base2)
      ;;

    # Friction
    kfric?*) # friction experiments
      kfric=-${params[0]}
      ;;

    # Damp full atmosphere
    # Also includes diagonal experiments where multiple params changed
    katmos?*)
      # Check experiments with 'dash' in name, make sure enough params were
      # specified or set the other param ourselves.
      ktrop=-${params[0]}
      if [ "$suffix" != "$sweep" ]; then # i.e. experiment had a 'dash' in it
        case "$suffix" in
          # Special configurations
          anom) ktrop=-40,$ktrop ;;
          mean) ktrop=$ktrop,-40 ;;
          *) [ -z "${params[1]}" ] && raise "Need second param for diagonal experiment."
          # True 'diagonal' experiments
          case "$suffix" in # diagaonal experiment
            kfric) kfric=-${params[1]} ;;
            tgrad) delh=${params[1]} ;;
            tmean) tmean=${params[1]} ;;
            tshift) exph=${params[1]} ;;
            global) forcing_global=.true. q0_global=${params[1]} ;;
            surface) forcing_surface=.true. q0_surface=${params[1]} ;;
            arctic) butler_arctic=.true. q0_arctic=${params[1]} ;;
            vortex) butler_vortex=.true. q0_vortex=${params[1]} ;;
            tropical) butler_tropical=.true. q0_tropical=${params[1]} ;;
            *) raise "Unknown sweep ${sweep}." ;;
          esac
          ;;
        esac
      fi
      # Match strat and meso forcing to ktrop, but this should not change anything
      # for Held-Suarez forcing
      kstrat=$ktrop
      kmeso=$ktrop
      # Next, separately scale boundary layer damping rate
      for iktrop in ${ktrop/,/ }; do
        case $blopt in
          [01]) ikbl=$iktrop ;; # keep surface boundary layer equal to value in rest of atmosphere
          2) ikbl=-$(bc -l <<< "scale=3; ${iktrop#-}/10") ;; # hold ratio constant; i.e. keep it at 10
          3) ikbl=-$(bc -l <<< "scale=3; (4^-1 + (${iktrop#-}^-1 - 40^-1))^-1") ;; # preserve 'boundary layer' component
          *) raise "Unknown blopt ${blopt}." ;;
        esac
        kbl=$kbl,$ikbl # mean and anomaly components
      done
      kbl=${kbl#,} # trim leading comma
      ;;

    # Damp stratosphere
    kstrat?*) # stratosphere damping experiments
      # Parse the depth and stuff
      kstrat=-${params[0]}
      kdepth=${params[1]} # param 2 is depth of transition region
      [ -z "$kdepth" ] && raise "Need to specify transition depth as second parameter."
      # Whether to damp mesosphere more stronly
      damp=${prefix#*[^12]}
      case "$damp" in
        1) damp=constant ;;
        2) damp=linear ;;
        *) raise "Unknown stratosphere damping option ${damp}." ;;
      esac
      # Detect other options
      case "$suffix" in
        anom) kstrat=-40,$kstrat ;;
        mean) kstrat=$kstrat,-40 ;;
        *) raise "Unknown suffix option ${suffix}." ;;
      esac
      ;;

    # Perturb the equator-pole temp gradient
    tshift?)
      exph=${params[0]}
      # Boundary layer
      case "$blopt" in
        [01]) kbl=-40 ;; # keep surface boundary layer equal to value in rest of atmosphere ;;
        [23]) ;; # do nothing
        *) raise "Unknown blopt ${blopt}."
      esac
      ;;

    # The mean temp ones
    tmean?*)
      tmean=${params[0]}
      # Boundary layer
      case "$blopt" in
        [01]) kbl=-40 ;; # keep surface boundary layer equal to value in rest of atmosphere ;;
        [23]) ;; # do nothing
        *) raise "Unknown blopt ${blopt}."
      esac
      ;;

    # The equator-pole equilibrium difference
    tgrad?*) # temp gradient experiments
      delh=${params[0]}
      # Boundary layer
      case "$blopt" in
        [01]) kbl=-40 ;; # keep surface boundary layer equal to value in rest of atmosphere ;;
        [23]) ;; # do nothing
        *) raise "Unknown blopt ${blopt}."
      esac
      # Diagonal experiments
      if [ "$suffix" != "$sweep" ]; then # i.e. experiment had a 'dash' in it
        [ -z "${params[1]}" ] && raise "Need second param for diagonal experiment."
        case "$suffix" in
          tshift) exph=${params[1]} ;;
          *) raise "Unknown sweep ${sweep}." ;;
        esac
      fi
      ;;

    # Unknown
    *) raise "Unknown experiment series \"$sweep\"."
      ;;
  esac

  #----------------------------------------------------------------------------#
  # Store namelist changes in two arrays, so we can also
  # nicely print those changes
  #----------------------------------------------------------------------------#
  # Forcing settings
  nml_add teq_mode "'$force'" damp_mode "'$force'" strat_damp "'$damp'" # modes
  nml_add delh "$delh" t_mean "$tmean" exp_h "$exph" # equilibrium temp stuff
  nml_add ktrop "$ktrop" kfric "$kfric" kbl "$kbl" kstrat "$kstrat" kmeso "$kmeso" z_kdepth "$kdepth" # damping
  nml_add butler_arctic "$butler_arctic" q0_arctic "$q0_arctic"
  nml_add butler_tropical "$butler_tropical" q0_tropical "$q0_tropical"
  nml_add butler_vortex "$butler_vortex" q0_vortex "$q0_vortex"
  nml_add forcing_global "$forcing_global" q0_global "$q0_global"
  nml_add forcing_surface "$forcing_surface" q0_surface "$q0_surface" # global constant forcing
  # Timing variables
  # These ones are not experiment dependent so far, and are *global*
  nml_add dt_atmos "$dt" days "$days" seconds "$secs"
  # Set horizontal coordinates
  ntrunc=${reso%l*}
  ntrunc=${ntrunc#t}
  case $ntrunc in
    42)  nlat=64  ;;
    63)  nlat=96  ;;
    85)  nlat=128 ;;
    95)  nlat=144 ;; # for 36-core Cheyenne nodes
    106) nlat=160 ;;
    170) nlat=256 ;;
    *) raise "Invalid truncation number \"$ntrunc\"." ;;
  esac
  nsphere=$(($ntrunc + 1)) # forget what difference between num fourier and num spherical means
  nlon=$(($nlat * 2)) # always twice the res
  nml_add num_fourier "$ntrunc" num_spherical "$nsphere" lat_max "$nlat" lon_max "$nlon"
  # Now vertical resolution options
  # Will raise error if string-specifier is unknown
  vert=${reso#*l}
  case $vert in
    *e) coord=input; levels=$srcdir/levels_ecmwf_${nlev}.nml ;; # ERA-Interim coordinates
    *p) coord=pk_sigma; nlev=${vert%p} ;;
    *s) coord=even_sigma; nlev=${vert%s} ;;
    *) raise "Unknown vertical coordinate identifier \"${vert}\"." ;;
  esac
  nml_add num_levels "$nlev" vert_coord_option "'$coord'"

  #----------------------------------------------------------------------------#
  # Add arrays to namelist
  #----------------------------------------------------------------------------#
  # Copy over the default namelist
  nml=$exp_dir/input.nml
  nml_default=$srcdir/general_default.nml
  cp $nml_default $nml # move over defaut
  echo "Copied $nml_default to $nml"
  # Message
  index=0
  width=6
  while [ $index -le ${#nml_params[@]} ]; do
    message+="${nml_params[@]:$index:$width}\n${nml_values[@]:$index:$width}\n\n"
    let index+=$width
  done
  echo "Updated namelist with:"
  printf "$message" | column -t
  # Also print CFL number
  # 100m/s is around 200mph, which is feasible in jet stream
  echo "CFL num for 100m/s wind: $(echo "scale=3; 100 / ((3.14 * 6371000.0 / $nlat ) / $dt)" | bc | awk '{printf "%f", $0}')."
  # Add forcing namelist
  nml_forcing=$srcdir/forcing_default.nml
  if [ ! -r "$nml_forcing" ]; then
    raise "File \"$nml_forcing\" not found."
  fi
  cat $nml_forcing >>$nml # append that shit
  # Add coordinate namelist, potentially
  if [ -n "$levels" ]; then
    if ! [ -r "$levels" ]; then 
      raise "File \"$levels\" not found."
    fi
    cat $levels >>$nml
  fi
  # Now loop through variables and assign them
  # Only modify the parameter sweep variables, resolution variables, and
  # timing variables. For others, just change in the namelist file directly.
  [ ${#nml_params[@]} -ne ${#nml_values[@]} ] && raise "One of the batch script namelist params is unset."
  for i in $(seq 0 $((${#nml_params[@]}-1))); do
    key=${nml_params[$i]}
    val=${nml_values[$i]}
    [ -z "$key" ] && continue # e.g. stratosphere timescale should be empty
    if ! grep '^[ \t]*\b'${key}'\b' $nml &>/dev/null; then
      raise "Param \"${key}\" not found in namelist."
    fi
    space='\([ \t]*\)' # space atom; more readable to set it as a variable
    sed -i 's/^'"${space}${key}${space}"'='"${space}"'.*$/\1'${key}'\2=\3'${val}',/g' $nml
    sed -i 's/^'"${space}${key}${space}"'='"${space}"'.*$/\1'${key}'\2=\3'${val}',/g' $nml
  done
  # Remove comments to be safe
  sed -i 's/!.*$//g;/^[ \t]*$/d' $nml # remove comments

  #------------------------------------------------------------------------#
  # Set up diag table; so far this is kept very simple
  #------------------------------------------------------------------------#
  diag=$exp_dir/diag_table
  cp $srcdir/$diag_default $diag
  sed -i 's/filename/"'$filename'"/g;s/outfreq/'$outfreq'/g;s/frequnits/"'$frequnits'"/g' $diag
  sed -i 's/#.*$//g;/^[ \t]*$/d' $diag # remove comments, empty lines, for clarity
}

#------------------------------------------------------------------------------#
# Loop through different parameters
# Settings to run entire loop as concurrent qsub processes, or run
# serially on a normal server
#------------------------------------------------------------------------------#
# First set looping params
echo "Forcing: $force, Sweep: $sweep, Resolution: $reso"
exp_names=() # record completed experiments
cwd=$(pwd)
if [[ $sweep =~ base ]]; then
  params1=(na)
  params2=(na)
elif [ -z "$params1" ]; then
  raise "You must define an array of parameters with e.g. --1=10,20,30"
elif [ -z "$params2" ]; then
  params2=(na)
fi
# Parameter sweeps
for param2 in ${params2[@]}; do
  for param1 in ${params1[@]}; do
    # Set the exp_name and exp_restart variables
    # Prevent repeating experiments during diagonal param sweeps
    unset -v exp_name exp_restart # restart, then exp_name may set it again
    exp_name $sweep $param1 $param2
    if member $exp_name ${exp_names[@]}; then
      echo "Already ran ${exp_name} in this loop."
      continue
    fi
    exp_names+=($exp_name) # record in list
    if $testmode; then
      exp_dir="$scratch/test"
    else
      exp_dir="$scratch/$exp_name"
    fi
    ! [ -d "$exp_dir" ] && mkdir "$exp_dir"
    log="$exp_dir/run.log" # e.g use the testing name
    echo "Experiment name: ${exp_name}." | tee $log

    # Prepare namelist, diag table, and flags for experiment
    # NOTE: This sets global variables 'exp_name' and 'exp_dir'
    unset flags
    exp_setup $exp_name 1>>$log
    if [ -n "$exp_restart" ]; then
      ! [ -d $scratch/${exp_restart} ] && exp_restart="${exp_restart}c"
      ! [ -d $scratch/${exp_restart} ] && echo "Warning: Restart directory $exp_restart not found." && continue
      echo "Restart from: ${exp_restart}" | tee $log
      flags+="-rd=$scratch/$exp_restart/$rdays " # override with this restart directory
    fi
    ! [ -z "$txyzdata" ]  && flags+="-dxyz=$txyzdata " # keep XYZ data
    ! [ -z "$tnodata" ]   && flags+="-dn=$tnodata "    # record zero data
    ! [ -z "$tspindown" ] && flags+="-ds=$tspindown "  # record zero data

    # Run experiment (or just echo command for dryrun)
    let np=cores*nodes
    exp_run="./drycore_run $exp_dir $flags_global $flags -ts=$tstart -te=$tend -c=$np"
    $dryrun && echo $exp_run && continue
    # Logs
    echo "Log file: $log" # so can copy paste this
    echo "Run flags: $flags_global"
    # On server
    # NOTE: Need the eval so the quotes in the -p argument are evaluated
    if ! $super; then
      eval "$exp_run &>>$log"
      stat=$?
      if ! $testmode; then
        echo "Exit status: ${stat}"
        if $mail; then
          printf "Experiment ${exp_name} finished with exit status ${stat}. The call signature was '${exp_run}'.\n\nThe logfile is pasted below.\n\n$(cat $log)\n\nThe namelist is pasted below.\n\n$(cat $exp_dir/input.nml)" \
            | mail -s "${exp_name} status: ${stat}" lukelbd@gmail.com
        fi
      fi
      if [ $stat -ne 0 ]; then
        echo "Warning: $exp_name integration failed."
        continue # keyboard interruption does not trigger this
      fi
    # On supercomputer, submit via qsub
    # NOTE: See Readme for core selection rationale
    # NOTE: Use economy queue because I work at weird times, have never
    # really noticed big slowdowns or wait times
    else
      ! [ -d jobs ] && mkdir jobs
      qsub <<EOF
#!/usr/bin/env bash
# Job name, account, email
#PBS -N $exp_name
#PBS -A UCSU0071
#PBS -M lukelbd@gmail.com
#PBS -m ae
#PBS -q $queue
# Job specs (max possible walltime is 12 hours)
#PBS -l walltime=$walltime:00
#PBS -l select=$nodes:ncpus=$cores:mpiprocs=$cores
# Output
#PBS -j oe
#PBS -k o
# Command
$exp_run &>>$log
EOF
    fi
    # Wrap up
    ! [ -d $HOME/data ] && mkdir $HOME/data
    ! [ -d $HOME/data/forcing ] && mkdir $HOME/data/forcing
    unset flags
    let counter+=1
    cd $cwd # ensure are still in same directory
    echo
  done
done
# echo # space
